# 8-形状/轮廓识别

```python
import cv2
import numpy as np

path = 'Resources/shapes.png'
img = cv2.imread(path)

cv2.imshow("Original", img)
cv2.waitKey(0)
```

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182113868.png" alt="image-20251109221543269" style="zoom:25%;" />

我们将会检测上面的每一个图形，并且将分类它属于哪个类别，展示它有多少个角点，以及每个形状的面积。

```python
import cv2
import numpy as np

path = 'Resources/shapes.png'
img = cv2.imread(path)

def stackImages(scale,imgArray):
    rows = len(imgArray)
    cols = len(imgArray[0])
    rowsAvailable = isinstance(imgArray[0], list)
    width = imgArray[0][0].shape[1]
    height = imgArray[0][0].shape[0]
    if rowsAvailable:
        for x in range ( 0, rows):
            for y in range(0, cols):
                if imgArray[x][y].shape[:2] == imgArray[0][0].shape [:2]:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale)
                else:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale)
                if len(imgArray[x][y].shape) == 2: imgArray[x][y]= cv2.cvtColor( imgArray[x][y], cv2.COLOR_GRAY2BGR)
        imageBlank = np.zeros((height, width, 3), np.uint8)
        hor = [imageBlank]*rows
        hor_con = [imageBlank]*rows
        for x in range(0, rows):
            hor[x] = np.hstack(imgArray[x])
        ver = np.vstack(hor)
    else:
        for x in range(0, rows):
            if imgArray[x].shape[:2] == imgArray[0].shape[:2]:
                imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale)
            else:
                imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None,scale, scale)
            if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR)
        hor= np.hstack(imgArray)
        ver = hor
    return ver

# 图像预处理
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# 将其转换为灰度图像
imgBlur = cv2.gaussianBlur(imgGray, (7, 7), 1)# 添加一点模糊效果
# 高斯模糊可以让数据值偏向一致，便于后续高低阈值区分平滑
imgStack = stackImages(0.6, ([img, imgGray, imgBlur]))

cv2.imshow("Original", img)
cv2.imshow("Gray", imgGray)
cv2.imshow("Blur", imgBlur)
cv2.imshow("Stack", imgStack)
cv2.waitKey(0)
```

- `cv2.gaussianBlur(imgGray, (7, 7), 1)`

  - `imgGray`:输入图像
  - `(7, 7)`：高斯核（滤波窗口）的尺寸 `ksize`，格式为 `(width, height)`，必须是**正的奇数**（如 `3×3`、`5×5`、`7×7`）。核尺寸越大，模糊效果越强（图像细节损失越多）。核的宽度和高度可不同（如 `(5, 7)`），但实际中常用正方形核，保证水平和垂直方向的模糊程度一致。

  - `1`：
  - 水平方向的高斯标准差sigmaX，控制高斯函数的 “宽窄”
    - `sigmaX` 越大，高斯函数越平缓，模糊时远处像素的权重越高（相对于sigmaX越小时），模糊效果越强；
    - `sigmaX` 越小，高斯函数越尖锐，模糊时仅考虑中心附近像素，模糊效果较弱。
    - 若未指定 `sigmaY`（垂直方向标准差），则默认 `sigmaY = sigmaX`，即水平和垂直方向模糊程度相同。

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182113884.png" alt="image-20251109225012650" style="zoom:25%;" />

![image-20251109225045195](https://typora3.oss-cn-shanghai.aliyuncs.com/202511182113852.png)

使用canny进行边缘检测

```python
import cv2
import numpy as np

path = 'Resources/shapes.png'
img = cv2.imread(path)

def stackImages(scale,imgArray):
    rows = len(imgArray)
    cols = len(imgArray[0])
    rowsAvailable = isinstance(imgArray[0], list)
    width = imgArray[0][0].shape[1]
    height = imgArray[0][0].shape[0]
    if rowsAvailable:
        for x in range ( 0, rows):
            for y in range(0, cols):
                if imgArray[x][y].shape[:2] == imgArray[0][0].shape [:2]:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale)
                else:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale)
                if len(imgArray[x][y].shape) == 2: imgArray[x][y]= cv2.cvtColor( imgArray[x][y], cv2.COLOR_GRAY2BGR)
        imageBlank = np.zeros((height, width, 3), np.uint8)
        hor = [imageBlank]*rows
        hor_con = [imageBlank]*rows
        for x in range(0, rows):
            hor[x] = np.hstack(imgArray[x])
        ver = np.vstack(hor)
    else:
        for x in range(0, rows):
            if imgArray[x].shape[:2] == imgArray[0].shape[:2]:
                imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale)
            else:
                imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None,scale, scale)
            if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR)
        hor= np.hstack(imgArray)
        ver = hor
    return ver

# 图像预处理
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# 将其转换为灰度图像
imgBlur = cv2.GaussianBlur(imgGray, (7, 7), 1)# 添加一点模糊效果
imgCanny = cv2.Canny(imgBlur, 50, 50)
imgBlank = np.zeros_like(img)# 存储边缘
imgStack = stackImages(0.6, ([img, imgGray, imgBlur],
                            [imgCanny, imgBlank, imgBlank]))


cv2.imshow("Stack", imgStack)
cv2.waitKey(0)
```

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182113991.png" alt="image-20251109225504187" style="zoom:25%;" />

- `cv2.Canny(imgBlur, 50, 50)`

  - `imgBlur`：输入图像

  - `50`：低阈值（也叫下阈值），低于该阈值的像素点会被判定为 “非边缘”，直接丢弃。

  - `50`：高阈值（也叫上阈值），用于确定 “强边缘”。高于该阈值的像素点会被直接判定为 “强边缘”（确定的边缘），保留并作为后续边缘连接的种子点。

    > 通常情况下，`threshold1`（低阈值）应小于 `threshold2`（高阈值，推荐比例为 1:2 或 1:3，如 `(50, 150)`）。
    >
    > 介于两者之间的像素为 “弱边缘”，仅当与 “强边缘” 相连时才被保留（避免孤立的弱边缘被误判）。

```python
import cv2
import numpy as np

path = 'Resources/shapes.png'
img = cv2.imread(path)
imgContour = img.copy()# 复制图片

def stackImages(scale,imgArray):
    rows = len(imgArray)
    cols = len(imgArray[0])
    rowsAvailable = isinstance(imgArray[0], list)
    width = imgArray[0][0].shape[1]
    height = imgArray[0][0].shape[0]
    if rowsAvailable:
        for x in range ( 0, rows):
            for y in range(0, cols):
                if imgArray[x][y].shape[:2] == imgArray[0][0].shape [:2]:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale)
                else:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale)
                if len(imgArray[x][y].shape) == 2: imgArray[x][y]= cv2.cvtColor( imgArray[x][y], cv2.COLOR_GRAY2BGR)
        imageBlank = np.zeros((height, width, 3), np.uint8)
        hor = [imageBlank]*rows
        hor_con = [imageBlank]*rows
        for x in range(0, rows):
            hor[x] = np.hstack(imgArray[x])
        ver = np.vstack(hor)
    else:
        for x in range(0, rows):
            if imgArray[x].shape[:2] == imgArray[0].shape[:2]:
                imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale)
            else:
                imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None,scale, scale)
            if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR)
        hor= np.hstack(imgArray)
        ver = hor
    return ver

def getContours(img):
    # 获取所有轮廓
    contours, hierarchy = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    # 新的opencv findContours返回三个参数，老师这里用的旧版的，选第二个参数返回就是contours
     for cnt in contours:
            area = cv2.contourArea(cnt)# 计算面积
            print(area)
            # 绘制所有轮廓(蓝色表示)
            cv2.drawContours(imgContour, cnt, -1, (255, 0, 0), 3)
            
    
    
# 图像预处理
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# 将其转换为灰度图像
imgContour = img.copy()
imgBlur = cv2.GaussianBlur(imgGray, (7, 7), 1)# 添加一点模糊效果
imgCanny = cv2.Canny(imgBlur, 50, 50)
getContours(imgCanny)
imgBlank = np.zeros_line(img)# 存储边缘
imgStack = stackImages(0.6, ([img, imgGray, imgBlur],
                            [imgCanny, imgContour, imgBlank]))



cv2.imshow("Stack", imgStack)
cv2.waitKey(0)
```

cv2.RETR_EXTERNAL 是 OpenCV 中的一个轮廓检测模式，用于找到图像中的外部轮廓

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182113948.png" alt="image-20251110224049953" style="zoom:25%;" />

```python
# 加入面积筛选
import cv2
import numpy as np

path = 'Resources/shapes.png'
img = cv2.imread(path)
imgContour = img.copy()# 复制图片

def stackImages(scale,imgArray):
    rows = len(imgArray)
    cols = len(imgArray[0])
    rowsAvailable = isinstance(imgArray[0], list)
    width = imgArray[0][0].shape[1]
    height = imgArray[0][0].shape[0]
    if rowsAvailable:
        for x in range ( 0, rows):
            for y in range(0, cols):
                if imgArray[x][y].shape[:2] == imgArray[0][0].shape [:2]:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale)
                else:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale)
                if len(imgArray[x][y].shape) == 2: imgArray[x][y]= cv2.cvtColor( imgArray[x][y], cv2.COLOR_GRAY2BGR)
        imageBlank = np.zeros((height, width, 3), np.uint8)
        hor = [imageBlank]*rows
        hor_con = [imageBlank]*rows
        for x in range(0, rows):
            hor[x] = np.hstack(imgArray[x])
        ver = np.vstack(hor)
    else:
        for x in range(0, rows):
            if imgArray[x].shape[:2] == imgArray[0].shape[:2]:
                imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale)
            else:
                imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None,scale, scale)
            if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR)
        hor= np.hstack(imgArray)
        ver = hor
    return ver

def getContours(img):
    # 获取所有轮廓
    contoures, hierarchy = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    # 新的opencv findContours返回三个参数，老师这里用的旧版的，选第二个参数返回就是contours
     for cnt in contours:
            area = cv2.contourArea(cnt)# 计算面积
            print(area)
            # 检测面积
            if area > 500:
                # 绘制所有轮廓(蓝色表示)
                cv2.drawContours(imgContour, cnt, -1, (255, 0, 0), 3)
                """
                -1（contourIdx）: 指定要绘制的轮廓索引;
                - 若为正数（如 0、1），表示绘制 contours 列表中对应索引的单个轮廓（适用于 contours 是多个轮廓的列表时）。
                - 若为 -1，表示绘制所有轮廓（此处 cnt 若为单个轮廓，-1 仍会绘制该轮廓；若 cnt 是轮廓列表，-1 会绘制所有轮廓）。
                """
            
    
    
# 图像预处理
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# 将其转换为灰度图像
imgBlur = cv2.gaussianBlur(imgGray, (7, 7), 1)# 添加一点模糊效果
imgCanny = cv2.Canny(imgBlur, 50, 50)
getCOntours(imgCanny)
imgBlank = np.zeros_line(img)# 存储边缘
imgStack = stackImages(0.6, ([img, imgGray, imgBlur],
                            [imgCanny, imgContour, imgBlank]))



cv2.imshow("Stack", imgStack)
cv2.waitKey(0)
```

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182113009.png" alt="image-20251110224356137" style="zoom:25%;" />

```python
# 加入计算周长(每个轮廓的长度) & 多少个角
import cv2
import numpy as np

path = 'Resources/shapes.png'
img = cv2.imread(path)
imgContour = img.copy()# 复制图片

def stackImages(scale,imgArray):
    rows = len(imgArray)
    cols = len(imgArray[0])
    rowsAvailable = isinstance(imgArray[0], list)
    width = imgArray[0][0].shape[1]
    height = imgArray[0][0].shape[0]
    if rowsAvailable:
        for x in range ( 0, rows):
            for y in range(0, cols):
                if imgArray[x][y].shape[:2] == imgArray[0][0].shape [:2]:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale)
                else:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale)
                if len(imgArray[x][y].shape) == 2: imgArray[x][y]= cv2.cvtColor( imgArray[x][y], cv2.COLOR_GRAY2BGR)
        imageBlank = np.zeros((height, width, 3), np.uint8)
        hor = [imageBlank]*rows
        hor_con = [imageBlank]*rows
        for x in range(0, rows):
            hor[x] = np.hstack(imgArray[x])
        ver = np.vstack(hor)
    else:
        for x in range(0, rows):
            if imgArray[x].shape[:2] == imgArray[0].shape[:2]:
                imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale)
            else:
                imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None,scale, scale)
            if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR)
        hor= np.hstack(imgArray)
        ver = hor
    return ver

def getContours(img):
    # 获取所有轮廓
    contoures, hierarchy = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    # 新的opencv findContours返回三个参数，老师这里用的旧版的，选第二个参数返回就是contours
     for cnt in contours:
            area = cv2.contourArea(cnt)# 计算面积
            print(area)
            # 检测面积
            if area > 500:
                # 绘制所有轮廓(蓝色表示)
                cv2.drawContours(imgContour, cnt, -1, (255, 0, 0), 3)
                peri = cv2.arcLength(cnt, True)
                # 计算轮廓 cnt 的周长（弧长）
                print(peri)
			   approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)# 角的坐标
                print(len(approx))
                # 逼近后的多边形顶点坐标数组【形状为 (N, 1, 2)，N 为顶点数）】
                objCor = len(approx)
                # 创建bounding box边界框
                x, y, w, h = cv2.boundingRect(approx)
                # 绘制矩形框
                cv2.rectangle(imgContour, (x, y), (x+w, y+h), (0, 255, 0), 2)
                
                
# 图像预处理
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# 将其转换为灰度图像
imgBlur = cv2.gaussianBlur(imgGray, (7, 7), 1)# 添加一点模糊效果
imgCanny = cv2.Canny(imgBlur, 50, 50)
getCOntours(imgCanny)
imgBlank = np.zeros_line(img)# 存储边缘
imgStack = stackImages(0.6, ([img, imgGray, imgBlur],
                            [imgCanny, imgContour, imgBlank]))



cv2.imshow("Stack", imgStack)
cv2.waitKey(0)
```

- `approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)`
  - 对轮廓 `cnt` 进行多边形逼近，用更少的顶点近似表示轮廓（简化形状），核心用于识别规则形状（如矩形、三角形）。
  - `cnt`：原始轮廓。
  - `0.02 * peri`：逼近精度（即轮廓与逼近多边形的最大允许距离），通常设为周长的百分比（此处为 2%），值越小逼近越精细。
  - `True`：逼近后的多边形为**闭合的**。

1、根据轮廓获取曲线 2、根据曲线获取折线 3、根据折线获取拐点 4、挂点数就是角数

先是area面积，然后peri弧长，接着approx角的点坐标，最后len（approx）求点的数量（数组长度）

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182113548.png" alt="image-20251110225719939" style="zoom:25%;" />

接下来需要对这些对象进行分类，确定它们时圆形、三角形、矩形还是正方形

```python
# 加入计算周长(每个轮廓的长度) & 多少个角
import cv2
import numpy as np

path = 'Resources/shapes.png'
img = cv2.imread(path)
imgContour = img.copy()# 复制图片

def stackImages(scale,imgArray):
    rows = len(imgArray)
    cols = len(imgArray[0])
    rowsAvailable = isinstance(imgArray[0], list)
    width = imgArray[0][0].shape[1]
    height = imgArray[0][0].shape[0]
    if rowsAvailable:
        for x in range ( 0, rows):
            for y in range(0, cols):
                if imgArray[x][y].shape[:2] == imgArray[0][0].shape [:2]:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale)
                else:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale)
                if len(imgArray[x][y].shape) == 2: imgArray[x][y]= cv2.cvtColor( imgArray[x][y], cv2.COLOR_GRAY2BGR)
        imageBlank = np.zeros((height, width, 3), np.uint8)
        hor = [imageBlank]*rows
        hor_con = [imageBlank]*rows
        for x in range(0, rows):
            hor[x] = np.hstack(imgArray[x])
        ver = np.vstack(hor)
    else:
        for x in range(0, rows):
            if imgArray[x].shape[:2] == imgArray[0].shape[:2]:
                imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale)
            else:
                imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None,scale, scale)
            if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR)
        hor= np.hstack(imgArray)
        ver = hor
    return ver

def getContours(img):
    # 获取所有轮廓
    contoures, hierarchy = cv2.findContours(img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    # 新的opencv findContours返回三个参数，老师这里用的旧版的，选第二个参数返回就是contours
     for cnt in contours:
            area = cv2.contourArea(cnt)# 计算面积
            print(area)
            # 检测面积
            if area > 500:
                # 绘制所有轮廓(蓝色表示)
                cv2.drawContours(imgContour, cnt, -1, (255, 0, 0), 3)
                peri = cv2.arcLength(cnt, True)
                print(peri)
			   approx = cv2.approxPolyDP(cnt, 0.02 * peri, True)# 角的坐标
                print(len(approx))
                objCor = len(approx)
                # 创建bounding box边界框
                x, y, w, h = cv2.boundingRect(approx)
                if objCor == 3:
                    objectType = "Tri"
                elif objCor == 4:
                    aspRatio = w/float(h)
                    if aspRatio > 0.95 and aspRatio < 1.05:
                        # 存在0.05的误差
                        objectType = "Square"
                        # 正方形的高度 == 宽度（边长都相等）
                    else:
                        objectType = "Rectangle"
                elif objCor > 4:
                    objectType = "Circles"
                
                cv2.rectangle(imgContour, (x, y), (x+w, y+h), (0, 255, 0), 2)
                cv2.putText(imgContour, objectType, (x+(w//2)-10, y+(h//2)-10), cv2.FONT_HERSHEY_COMPLEX, 0.7, (0, 0, 0), 2)
                
                    
                
                
# 图像预处理
imgGray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)# 将其转换为灰度图像
imgBlur = cv2.gaussianBlur(imgGray, (7, 7), 1)# 添加一点模糊效果
imgCanny = cv2.Canny(imgBlur, 50, 50)
getCOntours(imgCanny)
imgBlank = np.zeros_line(img)# 存储边缘
imgStack = stackImages(0.8, ([img, imgGray, imgBlur],
                            [imgCanny, imgContour, imgBlank]))



cv2.imshow("Stack", imgStack)
cv2.waitKey(0)
```

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182113681.png" alt="image-20251112215806665" style="zoom:25%;" />