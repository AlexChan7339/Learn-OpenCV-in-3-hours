# 7-颜色识别

> 检测图片中的橘色颜色,我们需要将图片转换为HSV空间【全称为 Hue（色相）、Saturation（饱和度）、Value（明度）。它不同于 RGB 基于色光三原色的物理混合模型，而是从人眼对颜色的直观感受出发划分颜色维度】
>
> > **为什么要从BGR转到HSV？**
> >
> > BGR空间里有三个通道，HSV关于色调只有一个，方便调节
>
> <img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182109281.png" alt="image-20251109165324187" style="zoom:25%;" />

```python
import cv2
import numpy as np

path = "Resources/lambo.png"
img = cv2.imread(path)
imgHSV = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)# 转化为HSV空间

cv2.imshow("Original", img)
cv2.imshow("HSV", imgHSV)
cv2.waitKey(0)
```

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182109305.png" alt="image-20251109165805877" style="zoom:25%;" />

现在我们需要定义一些颜色值（范围），我们想要的颜色在哪里，也就是定义色调（H）、饱和度(S)以及值限制(V)；如果图像区域落下在那个颜色范围内，我们就抓住它

> OpenCv中，HSV取值范围：色调范围为 [0,179]，饱和度范围为 [0,255]，值范围为 [0,255]

但有一点要注意：实际上并不知道我们需要的橙色对应的HSV最小值和最大值，我们需要借助**滑块条**来实时显示值

```python
import cv2
import numpy as np

def empty(a):
    pass

path = "Resources/lambo.png"
cv2.namedWindow("TrackBars")# 命名窗口名字
cv2.resizeWindow("TrackBars", 640, 320)# 调整窗口大小
cv2.createTrackbar("Hue Min", "TrackBars", 0, 179, empty)# 创建滑块条

cv2.imshow("Original", img)
cv2.imshow("HSV", imgHSV)
cv2.waitKey(0)
```

- `cv2.createTrackbar("Hue Min", "TrackBars", 0, 179, empty)`

  - `"Hue Min"`：滑动条的名称（字符串）

  - `"TrackBars"`：滑动条所属的窗口名称（字符串）。该窗口必须已通过 `cv2.namedWindow("TrackBars")` 创建，滑动条会显示在这个窗口中。

  - `0`：滑动条的**初始值**。这里初始值设为 `0`，表示色相最小值的初始值为 0（HSV 中 H 通道的取值范围通常为 0~179）

    > 在 OpenCV 中，HSV 颜色空间的 `H` 通道经过归一化处理：原本 0°~360° 的色相范围被映射为 0~179（即 360°/2 = 180，便于用 8 位整数存储）。因此这里最大值设为 179，对应 HSV 中 H 通道的最大可能值。

  - `179`：滑动条的**最大值**

  - **`empty`**

    - 滑动条数值变化时触发的回调函数
      - 这里 `empty` 通常是一个自定义的空函数（如 `def empty(a): pass`），表示滑动条值变化时暂时不执行额外操作（仅更新数值本身）。

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182109231.png" alt="image-20251109171446054" style="zoom:25%;" />

我们需要6个HSV值，分别是色调最小值和最大值、饱和度的最小值和最大值、值的最大值和最小值

```python
import cv2
import numpy as np

def empty(a):
    pass

path = "Resources/lambo.png"
cv2.namedWindow("TrackBars")# 命名窗口名字
cv2.resizeWindow("TrackBars", 640, 320)# 调整窗口大小
cv2.createTrackbar("Hue Min", "TrackBars", 0, 179, empty)# 创建滑块条
cv2.createTrackbar("Hue Max", "TrackBars", 179, 179, empty)# 保持最大值始终位于最大值
cv2.createTrackbar("Sat Min", "TrackBars", 0, 255, empty)
cv2.createTrackbar("Sat Max", "TrackBars", 255, 255, empty)
cv2.createTrackbar("Val Min", "TrackBars", 0, 255, empty)
cv2.createTrackbar("Val Max", "TrackBars", 255, 255, empty)

img = cv2.imread(path)
imgHSV = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)# 转化为HSV空间

cv2.imshow("Original", img)
cv2.imshow("HSV", imgHSV)
cv2.waitKey(0)
```

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182109365.png" alt="image-20251109172736118" style="zoom:25%;" />

此时我们会得到6个滑动条

```python
import cv2
import numpy as np

def empty(a):
    pass

path = "Resources/lambo.png"
cv2.namedWindow("TrackBars")# 命名窗口名字
cv2.resizeWindow("TrackBars", 640, 320)# 调整窗口大小
cv2.createTrackbar("Hue Min", "TrackBars", 0, 179, empty)# 创建滑块条
cv2.createTrackbar("Hue Max", "TrackBars", 179, 179, empty)# 保持最大值始终位于最大值
cv2.createTrackbar("Sat Min", "TrackBars", 0, 255, empty)
cv2.createTrackbar("Sat Max", "TrackBars", 255, 255, empty)
cv2.createTrackbar("Val Min", "TrackBars", 0, 255, empty)
cv2.createTrackbar("Val Max", "TrackBars", 255, 255, empty)

while True:
    # 实时获取滑动条值并应用于图像分割
    
    img = cv2.imread(path)
    imgHSV = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)# 转化为HSV空间
    h_min = cv2.getTrackbarPos("Hue Min", "TrackBars")
    print(h_min)

    cv2.imshow("Original", img)
    cv2.imshow("HSV", imgHSV)
    cv2.waitKey(1)
    # 如果为cv2.waitKey(0)，则会一直显示为最小值，因为虽然UI界面中Hue Min值滑动了，但cv2.waitKey(0)需要键盘按下一个键后才会对print数值进行更新；
    # 但cv2.waitKey(1)则是每1ms处理1次事件：包括鼠标事件、滑动条事件、窗口刷新、图像更新
```

- `h_min = cv2.getTrackbarPos("Hue Min", "TrackBars")`
  - `"Hue Min"`：要获取数值的滑动条名称（字符串），需与之前用 `cv2.createTrackbar()` 创建时的名称完全一致（区分大小写）
  - `"TrackBars"`：滑动条所在的窗口名称（字符串），需与创建滑动条时指定的窗口名称一致。函数会从该窗口中查找名为 “`Hue Min`” 的滑动条。

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182109197.png" alt="image-20251109173644902" style="zoom: 25%;" />

滑动滑动条，可以看到左下角输出拦里的值会发生

```python
import cv2
import numpy as np

def empty(a):
    pass


path = 'Resources/lambo.png'
cv2.namedWindow("TrackBars")
cv2.resizeWindow("TrackBars",640,240)
cv2.createTrackbar("Hue Min","TrackBars",0,179,empty)
cv2.createTrackbar("Hue Max","TrackBars",179,179,empty)
cv2.createTrackbar("Sat Min","TrackBars",0,255,empty)
cv2.createTrackbar("Sat Max","TrackBars",255,255,empty)
cv2.createTrackbar("Val Min","TrackBars",0,255,empty)
cv2.createTrackbar("Val Max","TrackBars",255,255,empty)

while True:
    img = cv2.imread(path)
    imgHSV = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)
    h_min = cv2.getTrackbarPos("Hue Min","TrackBars")
    h_max = cv2.getTrackbarPos("Hue Max", "TrackBars")
    s_min = cv2.getTrackbarPos("Sat Min", "TrackBars")
    s_max = cv2.getTrackbarPos("Sat Max", "TrackBars")
    v_min = cv2.getTrackbarPos("Val Min", "TrackBars")
    v_max = cv2.getTrackbarPos("Val Max", "TrackBars")
    print(h_min,h_max,s_min,s_max,v_min,v_max)
    # 滑动滑动条，可以看到左下角输出拦里的值会发生
    lower = np.array([h_min, s_min, v_min])
    upper = np.array([h_max, s_max, v_max])
    mask = cv2.inRange(imgHSV, lower, upper)
    
    cv2.imshow("Original", img)
    cv2.imshow("HSV", imgHSV)
    cv2.imshow("Mask", mask)
    cv2.waitKey(1)
```

- `cv2.inRange(imgHSV, lower, upper)`
  - `imgHSV`：输入图像（通常是 HSV 颜色空间的图像，也可以是 BGR、Gray 等其他空间），数据类型为 NumPy 数组（`ndarray`）
  - `lower`：阈值范围的**下限**，是一个 NumPy 数组，元素数量与图像的通道数一致。对于 HSV 图像（3 通道），`lower` 的格式为 `[h_min, s_min, v_min]`，分别对应色相、饱和度、明度的最小值。
  - `upper`：阈值范围的**上限**，格式与 `lower` 一致，对应各通道的最大值。对于 HSV 图像，格式为 `[h_max, s_max, v_max]`。
- 运行后，通过移动滑块条，你可以看到值和mask图像是不断变化的。因此，我们需要想把所有我们不想要的颜色都设为黑色，将我们需要的颜色保持为白色
  - 先调整Hue Max值，将兰博的轮廓和填充显现出来，再依次调节Sat Min、Sat Max、Val Min、Val Max。建议不断更改这些值，让橘黄色区域越来越流畅光滑

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182109452.png" alt="image-20251109215138730" style="zoom:50%;" />

![image-20251109215554864](https://typora3.oss-cn-shanghai.aliyuncs.com/202511182109229.png)

我们将上面的值作为初始值,得到mask对应的橘色部分

```python
import cv2
import numpy as np

def empty(a):
    pass


path = 'Resources/lambo.png'
cv2.namedWindow("TrackBars")
cv2.resizeWindow("TrackBars",640,240)
cv2.createTrackbar("Hue Min","TrackBars",0,179,empty)
cv2.createTrackbar("Hue Max","TrackBars",19,179,empty)
cv2.createTrackbar("Sat Min","TrackBars",110,255,empty)
cv2.createTrackbar("Sat Max","TrackBars",240,255,empty)
cv2.createTrackbar("Val Min","TrackBars",153,255,empty)
cv2.createTrackbar("Val Max","TrackBars",255,255,empty)

while True:
    img = cv2.imread(path)
    imgHSV = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)
    h_min = cv2.getTrackbarPos("Hue Min","TrackBars")
    h_max = cv2.getTrackbarPos("Hue Max", "TrackBars")
    s_min = cv2.getTrackbarPos("Sat Min", "TrackBars")
    s_max = cv2.getTrackbarPos("Sat Max", "TrackBars")
    v_min = cv2.getTrackbarPos("Val Min", "TrackBars")
    v_max = cv2.getTrackbarPos("Val Max", "TrackBars")
    print(h_min,h_max,s_min,s_max,v_min,v_max)
    # 滑动滑动条，可以看到左下角输出拦里的值会发生
    lower = np.array([h_min, s_min, v_min])
    upper = np.array([h_max, s_max, v_max])
    mask = cv2.inRange(imgHSV, lower, upper)
    imgResult = cv2.bitwise_and(img, img, mask=mask)
    
    cv2.imshow("Original", img)
    cv2.imshow("HSV", imgHSV)
    cv2.imshow("Mask", mask)
    cv2.imshow("Result", imgResult)
    cv2.waitKey(1)
```

- `cv2.bitwise_and(img, img, mask=mask)`
  - `img`:输入图像 1，通常为原始图像（如 BGR 彩色图或灰度图）
  - `img`：输入图像2，提供运算的第二个像素数据源，与 `src1` 的像素一一对应运算，最终通过运算保留两张图的重叠高亮区域

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182109411.png" alt="image-20251109220707702" style="zoom:25%;" />

```python
import cv2
import numpy as np

# 创建两张不同的图像
src1 = np.zeros((200, 200), dtype=np.uint8)
src2 = np.zeros((200, 200), dtype=np.uint8)

# 给src1画白色圆形，src2画白色矩形
cv2.circle(src1, (100, 100), 50, 255, -1)
# 255：圆的颜色 color，根据图像类型（灰度 / 彩色）有不同含义：
# 若 src1 是灰度图：255 表示白色（灰度值范围 0~255，0 为黑色，255 为白色）。
# 若 src1 是彩色图（BGR）：255 需表示为 (255, 0, 0) 等三通道元组
# -1：表示填充圆形内部，即绘制一个实心圆（边缘和内部均为指定颜色）。
cv2.rectangle(src2, (50, 50), (150, 150), 255, -1)

# 按位与：仅保留两张图中都为白色（255）的重叠区域
result = cv2.bitwise_and(src1, src2)

# 显示结果
cv2.imshow("src1（圆形）", src1)
cv2.imshow("src2（矩形）", src2)
cv2.imshow("result（重叠区域）", result)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

结果中只有圆形和矩形的重叠部分是白色，其他区域为黑色。这里 `src1` 和 `src2` 是不同图像，各自提供不同的像素信息，共同决定运算结果。

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182219403.png" alt="image-20251118221906267" style="zoom:25%;" />

我们运用上一章的值，将这几张照片合并起来，不用在多个窗口上进行展示

```python
import cv2
import numpy as np

def empty(a):
    pass

def stackImages(scale,imgArray):
    rows = len(imgArray)
    cols = len(imgArray[0])
    rowsAvailable = isinstance(imgArray[0], list)
    width = imgArray[0][0].shape[1]
    height = imgArray[0][0].shape[0]
    if rowsAvailable:
        for x in range ( 0, rows):
            for y in range(0, cols):
                if imgArray[x][y].shape[:2] == imgArray[0][0].shape [:2]:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale)
                else:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale)
                if len(imgArray[x][y].shape) == 2: imgArray[x][y]= cv2.cvtColor( imgArray[x][y], cv2.COLOR_GRAY2BGR)
        imageBlank = np.zeros((height, width, 3), np.uint8)
        hor = [imageBlank]*rows
        hor_con = [imageBlank]*rows
        for x in range(0, rows):
            hor[x] = np.hstack(imgArray[x])
        ver = np.vstack(hor)
    else:
        for x in range(0, rows):
            if imgArray[x].shape[:2] == imgArray[0].shape[:2]:
                imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale)
            else:
                imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None,scale, scale)
            if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR)
        hor= np.hstack(imgArray)
        ver = hor
    return ver

path = 'Resources/lambo.png'
cv2.namedWindow("TrackBars")
cv2.resizeWindow("TrackBars",640,240)
cv2.createTrackbar("Hue Min","TrackBars",0,179,empty)
cv2.createTrackbar("Hue Max","TrackBars",19,179,empty)
cv2.createTrackbar("Sat Min","TrackBars",110,255,empty)
cv2.createTrackbar("Sat Max","TrackBars",240,255,empty)
cv2.createTrackbar("Val Min","TrackBars",153,255,empty)
cv2.createTrackbar("Val Max","TrackBars",255,255,empty)

while True:
    img = cv2.imread(path)
    imgHSV = cv2.cvtColor(img,cv2.COLOR_BGR2HSV)
    h_min = cv2.getTrackbarPos("Hue Min","TrackBars")
    h_max = cv2.getTrackbarPos("Hue Max", "TrackBars")
    s_min = cv2.getTrackbarPos("Sat Min", "TrackBars")
    s_max = cv2.getTrackbarPos("Sat Max", "TrackBars")
    v_min = cv2.getTrackbarPos("Val Min", "TrackBars")
    v_max = cv2.getTrackbarPos("Val Max", "TrackBars")
    print(h_min,h_max,s_min,s_max,v_min,v_max)
    # 滑动滑动条，可以看到左下角输出拦里的值会发生
    lower = np.array([h_min, s_min, v_min])
    upper = np.array([h_max, s_max, v_max])
    mask = cv2.inRange(imgHSV, lower, upper)
    imgResult = cv2.bitwise_and(img, img, mask=mask)
    
    cv2.imshow("Original", img)
    cv2.imshow("HSV", imgHSV)
    cv2.imshow("Mask", mask)
    cv2.imshow("Result", imgResult)
    imgStack = stackImages(0.6, ([img, imgHSV], [mask, imgResult]))
    cv2.imshow("Stacked Images", imgStack)
    cv2.waitKey(1)
```

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182109708.png" alt="image-20251109221213550" style="zoom:25%;" />

此时我们也可以通过调节TrackBar观察四张图的变化

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511182109775.png" alt="image-20251109221319360" style="zoom:25%;" />