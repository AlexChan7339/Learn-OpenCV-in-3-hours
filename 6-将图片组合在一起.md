# 6-将图片组合在一起

如果你有很多图片，而你需要一次又一次运行它，很麻烦。所以我们可以将所有图片放在同一个窗口中。

```python
import cv2
import numpy as np
img = cv2.imread("Resources/lena.png")
# 需要将它与自己堆叠起来
imgHor = np.hstack((img, img))# 实质上是像素值的横向拼接
# hstack:Horrzontal Stack
imgVer = np.vstack((img, img))
# vstack:Vertical Stack

cv2.imshow("Horizontal", imgHor)
cv2.imshow("Vertical", imgVer)
cv2.waitKey(0)
```

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511172239412.png" alt="image-20251109121713264" style="zoom:25%;" />

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511172239383.png" alt="image-20251109121817623" style="zoom:25%;" />

> **上述此操作存在的问题：**
>
> 1. 无法调整图像大小:如果我想要堆叠超过2张图片，它将占据整个空间，或者它可能会超出电脑屏幕显示范围。
> 2. 如果是图片通道数量不相同，不是同是RGB或者灰度图像，即有一个是会的另一个是RGB，这个函数将不会工作

对于注意中的两点，可以通过自己编写函数进行解决

```python
import cv2
import numpy as np


def stackImages(scale,imgArray):
    rows = len(imgArray)
    cols = len(imgArray[0])
    rowsAvailable = isinstance(imgArray[0], list)
    width = imgArray[0][0].shape[1]
    height = imgArray[0][0].shape[0]
    if rowsAvailable:
        for x in range ( 0, rows):
            for y in range(0, cols):
                if imgArray[x][y].shape[:2] == imgArray[0][0].shape [:2]:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale)
                else:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale)
                if len(imgArray[x][y].shape) == 2: imgArray[x][y]= cv2.cvtColor( imgArray[x][y], cv2.COLOR_GRAY2BGR)
        imageBlank = np.zeros((height, width, 3), np.uint8)
        hor = [imageBlank]*rows
        hor_con = [imageBlank]*rows
        for x in range(0, rows):
            hor[x] = np.hstack(imgArray[x])
        ver = np.vstack(hor)
    else:
        for x in range(0, rows):
            if imgArray[x].shape[:2] == imgArray[0].shape[:2]:
                imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale)
            else:
                imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None,scale, scale)
            if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR)
        hor= np.hstack(imgArray)
        ver = hor
    return ver

img = cv2.imread('Resources/lena.png')
imgGray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

imgStack = stackImages(0.5,([img,img,img]))

cv2.imshow("ImageStack",imgStack)

cv2.waitKey(0)
```

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511172239349.png" alt="image-20251109122907025" style="zoom:33%;" />

```python
import cv2
import numpy as np


def stackImages(scale,imgArray):
    rows = len(imgArray)
    cols = len(imgArray[0])
    rowsAvailable = isinstance(imgArray[0], list)
    width = imgArray[0][0].shape[1]
    height = imgArray[0][0].shape[0]
    if rowsAvailable:
        for x in range ( 0, rows):
            for y in range(0, cols):
                # # 缩放图像至统一尺寸（以第一张图像为基准）
                if imgArray[x][y].shape[:2] == imgArray[0][0].shape [:2]:
                    # 尺寸相同，直接按scale缩放 
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (0, 0), None, scale, scale)
                else:
                    imgArray[x][y] = cv2.resize(imgArray[x][y], (imgArray[0][0].shape[1], imgArray[0][0].shape[0]), None, scale, scale)
                    # 此时后面的两个scale值可以忽略，且imgArray[0][0]尺寸已经转换为256 * 256，可以根据它的大小来进行专函
                if len(imgArray[x][y].shape) == 2: 
                    imgArray[x][y]= cv2.cvtColor( imgArray[x][y], cv2.COLOR_GRAY2BGR)
                # 若图像是灰度图（单通道，shape 长度为 2），则转换为彩色图（3 通道，BGR 格式），避免拼接时因通道数不同报错。
        imageBlank = np.zeros((height, width, 3), np.uint8)
        hor = [imageBlank]*rows	# 初始化行拼接结果列表
        for x in range(0, rows):
            hor[x] = np.hstack(imgArray[x])
            # 每行的图像水平拼接成一行大图，存储在 hor 列表中
        ver = np.vstack(hor)
        # 将所有行的大图垂直拼接成最终的网格大图。
    else:
        for x in range(0, rows):
            if imgArray[x].shape[:2] == imgArray[0].shape[:2]:
                imgArray[x] = cv2.resize(imgArray[x], (0, 0), None, scale, scale)
            else:
                imgArray[x] = cv2.resize(imgArray[x], (imgArray[0].shape[1], imgArray[0].shape[0]), None,scale, scale)
            if len(imgArray[x].shape) == 2: imgArray[x] = cv2.cvtColor(imgArray[x], cv2.COLOR_GRAY2BGR)
        hor= np.hstack(imgArray)
        ver = hor
    return ver

img = cv2.imread('Resources/lena.png')
imgGray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

imgStack = stackImages(0.5,([img,imgGray,img], [img,img,img]))

cv2.imshow("ImageStack",imgStack)

cv2.waitKey(0)
```

<img src="https://typora3.oss-cn-shanghai.aliyuncs.com/202511172239449.png" alt="image-20251109123055646" style="zoom:33%;" />

> **解释**hor 事先已经被设成固定大小的空图，为什么后面 hor[x] 的大小却又变成跟 np.hstack 的结果一样？
>
> 1. **`hor = [imageBlank] \* rows` 不会锁定 hor[x] 的大小**
>
> 这一行只是创建一个列表：
>
> ```python
> hor = [imageBlank] * rows
> ```
>
> 效果是：
>
> - 创建一个长度为 rows 的列表
> - 列表里的每个元素都是 **同一个** imageBlank 的引用
>
> 示例：
>
> ```python
> hor = [A, A, A]
> ```
>
> 其中 A 就是那张 `(height, width, 3)` 的空图。
>
> ------
>
> 2. **后面这一句完全覆盖掉 hor[x] 原本的值**
>
> ```python
> hor[x] = np.hstack(imgArray[x])
> ```
>
> 这是关键！！！
>
> 此时 `hor[x]` 不再是原来的 `imageBlank`，而是一个新生成的 NumPy 数组。
>
> 也就是说：
>
> > `hor[x]` 是通过赋值 **被替换掉** 的，而不是在 `imageBlank` 上修改。
>
> **原来的 imageBlank 形状完全无效，因为它被新的拼接图直接替换了。**
>
> ------
>
> **再直观一点的例子**：
>
> **原始 hor 是：**
>
> ```python
> hor = [空图(256×256), 空图(256×256)]
> ```
>
> **执行**：
>
> ```python
> hor[0] = np.hstack([img1, img2, img3])
> ```
>
> 假设拼完变成 `(256, 768, 3)`
>  那么 hor 的状态变为：
>
> ```python
> hor = [(256×768拼接图), 空图(256×256)]
> ```
>
> hor[0] 已经不再是 256×256。
>
> ------
>
> 3. **你以为它“调整大小”，但实际上是“直接被替换”**
>
> 这是个误会：
>
> 你看到的效果不是调整，而是：
>
> - hor[x] ← 一个新数组
>
> - 新数组大小来自 hstack 拼接
>
> - 旧 imageBlank 完全被覆盖掉了
>
> 它不是 resize，也不是自动变形，而是简单粗暴的赋值覆盖。

- ` rowsAvailable = isinstance(imgArray[0], list)`
  - 判断是否为二维列表（True：二维网格；False：一维单行）
    - 当 `rowsAvailable=True`（输入是二维列表，如 `[[img1, img2], [img3, img4]]`）
    - 当 `rowsAvailable=False`（输入是一维列表，如 `[img1, img2, img3]`）
- `cv2.resize(src, dsize, dst=None, fx=None, fy=None, interpolation=None)`
  - `src`：输入图像（需要调整尺寸的原始图像），可以是单通道（灰度图）或多通道（彩色图）。
  - **`dsize`（必选，或与`fx`/`fy`二选一）**：目标图像的尺寸，格式为 `(width, height)`（宽 × 高，注意与图像`shape`的`(height, width)`相反）。
    - 若指定`dsize`，则`fx`和`fy`可省略（会自动根据`dsize`计算缩放比例）。
    - 若设置为 `(0, 0)` 表示**不直接指定目标尺寸**，而是通过后面的缩放比例 `fx` 和 `fy` 来计算目标尺寸
  - **`fx`（可选，与`dsize`二选一）**：水平方向的缩放比例（倍数），例如`fx=0.5`表示宽度缩小到原来的 50%。
  - **`fy`（可选，与`dsize`二选一）**：垂直方向的缩放比例（倍数），例如`fy=2`表示高度放大到原来的 2 倍。
    - **注意**：若使用`fx`和`fy`，则`dsize`需设为`None`。
  - **`interpolation`（可选）**：插值方法，用于确定缩放时像素值的计算方式，影响缩放后图像的质量。常用选项：
    - - `cv2.INTER_NEAREST`：最近邻插值（速度快，质量低，适合快速缩放）。
      - `cv2.INTER_LINEAR`：双线性插值（默认值，质量中等，速度较快）。
      - `cv2.INTER_CUBIC`：双三次插值（质量高，细节保留好，速度较慢，适合放大图像）。
      - `cv2.INTER_AREA`：区域插值（适合缩小图像，能较好保留细节，避免模糊）。